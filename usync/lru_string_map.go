package usync

import (
	"math"
	"sync/atomic"
	"time"

	"github.com/cornelk/hashmap"
)

const (
	// generated by splitting the md5 sum of "hashmap"
	sipHashKey1_ = 0xdda7806a4847ec61
	sipHashKey2_ = 0xb5940c2623a5aabd
)

//
// Least Recently Used (LRU) eviction map
//
// Lookup is by unique hash, which can be computed with HashString, HashBytes,
// or by using one of he convenience accessors.
//
type LruMap struct {
	m        *hashmap.HashMap
	capacity int
	evicting AtomicBool
}

func NewLruMap(capacity int) *LruMap {
	return &LruMap{
		m:        hashmap.New(uintptr(capacity)),
		capacity: capacity,
	}
}

type lruv_ struct {
	value interface{}
	used  int64
}

//
// get the value from the map, setting ok to true if value found
//
func (this *LruMap) Get(key string) (rv interface{}, ok bool) {
	return this.GetByHash(HashString(key))
}

//
// get the value from the map, setting ok to true if value found
//
func (this *LruMap) GetByBytes(key []byte) (rv interface{}, ok bool) {
	return this.GetByHash(HashBytes(key))
}

//
// Refer to HashString or HashBytes
//
func (this *LruMap) GetByHash(hash uintptr) (rv interface{}, ok bool) {
	var it interface{}
	it, ok = this.m.GetHashedKey(hash)
	if ok {
		lruv := it.(*lruv_)
		rv = lruv.value
		atomic.AddInt64(&lruv.used, 1)
	}
	return
}

func (this *LruMap) GetAsString(key string) (rv string, ok bool) {
	var it interface{}
	it, ok = this.Get(key)
	if ok {
		rv = it.(string)
	}
	return
}

func (this *LruMap) GetOrAddAsString(key, value string) (rv string) {
	it := this.GetOrAddByHash(HashString(key),
		func() (v interface{}) { return value })
	rv = it.(string)
	return
}

//
// get the value from the map, or add it if not found
//
func (this *LruMap) GetOrAdd(key string, value interface{}) (rv interface{}) {
	return this.GetOrAddByHash(HashString(key),
		func() (v interface{}) { return value })
}

//
// get the value from the map, or add it from values produced by func
// if not found.
//
func (this *LruMap) GetOrAddF(
	key string,
	add func() (value interface{}),
) (
	rv interface{},
) {
	return this.GetOrAddByHash(HashString(key), add)
}

//
// get the value from the map, or add it from values produced by func
// if not found.
//
func (this *LruMap) GetOrAddByBytes(
	key []byte,
	add func() (value interface{}),
) (
	rv interface{},
) {
	return this.GetOrAddByHash(HashBytes(key), add)
}

//
// Refer to HashString or HashBytes
//
func (this *LruMap) GetOrAddByHash(
	hash uintptr,
	add func() (value interface{}),
) (
	rv interface{},
) {
	rv, ok := this.GetByHash(hash)
	if !ok && nil != add {
		rv = add()
		this.m.SetHashedKey(hash, &lruv_{value: rv})

		if this.capacity <= this.m.Len() && this.evicting.SetUnlessSet() {
			go this.evict()
		}
	}
	return
}

func (this *LruMap) evict() {
	for this.evicting.IsSet() {
		time.Sleep(100 * time.Millisecond)
		times := this.m.Len() - this.capacity
		for i := 0; i < times; i++ {
			var least int64 = math.MaxInt64
			var evictIt interface{}
			for kv := range this.m.Iter() {
				lruv := kv.Value.(*lruv_)
				if atomic.LoadInt64(&lruv.used) < least {
					evictIt = kv.Key
				}
			}
			this.m.Del(evictIt) // or, we could store hash in lruv_
		}
		if 0 >= times {
			this.evicting.Clear()
			break
		}
	}
}

//
// get the size of the map
//
func (this *LruMap) Len() (size int) {
	return this.m.Len()
}

/*
//
// Least Recently Used (LRU) eviction map
//
type LruMap struct {
	m        sync.Map
	length   int64
	Capacity int
	evicting  AtomicBool
}

type lruv_ struct {
	value interface{}
	used  int64
}

//
// get the value from the map, setting ok to true if value found
//
func (this *LruMap) Get(key string) (rv interface{}, ok bool) {
	var it interface{}
	it, ok = this.m.Load(key)
	if ok {
		lruv := it.(*lruv_)
		atomic.AddInt64(&lruv.used, 1)
		rv = lruv.value
	}
	return
}

func (this *LruMap) GetString(key string) (rv string, ok bool) {
	var it interface{}
	it, ok = this.Get(key)
	if ok {
		rv = it.(string)
	}
	return
}

func (this *LruMap) GetOrAddString(key, value string) (rv string) {
	var it interface{}
	var ok bool
	it, ok = this.Get(key)
	if !ok {
		it = this.add(key, value)
	}
	rv = it.(string)
	return
}

//
// get the value from the map, or add it if not found
//
func (this *LruMap) GetOrAdd(key string, value interface{}) (rv interface{}) {
	var ok bool
	rv, ok = this.Get(key)
	if !ok {
		rv = this.add(key, value)
	}
	return
}

//
// get the value from the map, or add it from values produced by func
// if not found.
//
// used in conjunction with key created using ustrings.UnsafeBytesToString,
// as that is a temp lookup key
//
func (this *LruMap) GetOrAddF(
	key string,
	add func() (key string, value interface{}),
) (
	rv interface{},
) {
	var ok bool
	rv, ok = this.Get(key)
	if !ok {
		k, v := add()
		rv = this.add(k, v)
	}
	return
}

func (this *LruMap) add(key string, value interface{}) (rv interface{}) {

	if nil == value {
		panic("cannot add nil value to LruMap")
	}
	if this.Capacity <= int(atomic.LoadInt64(&this.length)) &&
		this.evicting.SetUnlessSet() {
		go this.evict()
	}

	it, loaded := this.m.LoadOrStore(key, &lruv_{value: value})
	if !loaded { // stored
		atomic.AddInt64(&this.length, 1)
		rv = value
	} else {
		lruv := it.(*lruv_)
		atomic.AddInt64(&lruv.used, 1)
		rv = lruv.value
	}
	return
}

func (this *LruMap) evict() {
	for this.evicting.IsSet() {
		time.Sleep(100 * time.Millisecond)
		any := false
		length := int(atomic.LoadInt64(&this.length))
		for this.Capacity < length {
			var least int64 = math.MaxInt64
			var evictIt interface{}
			this.m.Range(
				func(kIt, vIt interface{}) bool {
					v := vIt.(*lruv_)
					if atomic.LoadInt64(&v.used) < least {
						evictIt = kIt
					}
					return true
				})
			any = true
			this.m.Delete(evictIt)
			length = int(atomic.AddInt64(&this.length, -1))
		}
		if !any {
			this.evicting.Clear()
			break
		}
	}
}

//
// get the size of the map
//
func (this *LruMap) Len() (size int) {
	return int(atomic.LoadInt64(&this.length))
}

*/

/*

This impl works better single threaded, but not so great multi threaded

//
// Least Recently Used (LRU) eviction map
//
// Sync'd with a mutex, so better when not too many threads
//
type LruStringLockMap struct {
	lock     sync.Mutex
	m        map[string]*lruv_
	Capacity int
}

//
// get the value from the map, setting ok to true if value found
//
func (this *LruStringLockMap) Get(key string) (rv string, ok bool) {
	this.lock.Lock()
	rv, ok = this.get(key)
	this.lock.Unlock()
	return
}

func (this *LruStringLockMap) get(key string) (rv string, ok bool) {
	var lruv *lruv_
	lruv, ok = this.m[key]
	if ok {
		lruv.used++
		rv = lruv.value
	}
	return
}

//
// get the value from the map, or add it if not found
//
func (this *LruStringLockMap) GetOrAdd(key, value string) (rv string) {
	var ok bool
	this.lock.Lock()
	rv, ok = this.get(key)
	if !ok {
		rv = this.add(key, value)
	}
	this.lock.Unlock()
	return
}

//
// get the value from the map, or add it if not found
//
func (this *LruStringLockMap) GetOrAddF(
	key string,
	add func() (key, value string),
) (
	rv string,
) {
	var ok bool
	this.lock.Lock()
	rv, ok = this.get(key)
	if !ok {
		k, v := add()
		rv = this.add(k, v)
	}
	this.lock.Unlock()
	return
}

func (this *LruStringLockMap) add(key, value string) (rv string) {

	if nil == this.m {
		this.m = make(map[string]*lruv_, this.Capacity)
	}

	lruv, ok := this.m[key]
	if ok {
		lruv.used++
		rv = lruv.value

	} else {
		if this.Capacity <= len(this.m) {
			evict(this.m)
		}
		this.m[key] = &lruv_{
			value: value,
		}
		rv = value
	}
	return
}

func evict(m map[string]*lruv_) {
	var least int64 = math.MaxInt64
	var evictK string
	for k, v := range m {
		if v.used < least {
			least = v.used
			evictK = k
		}
	}
	delete(m, evictK)
}

//
// get the size of the map
//
func (this *LruStringLockMap) Len() (size int) {
	this.lock.Lock()
	size = len(this.m)
	this.lock.Unlock()
	return
}
*/
